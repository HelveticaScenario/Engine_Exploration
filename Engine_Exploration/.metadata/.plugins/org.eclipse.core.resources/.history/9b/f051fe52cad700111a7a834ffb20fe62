function love.load()
--	require "middleclass"
--	require "boundingBoxes"
	width, height, fullscreen, vsync, fsaa = love.graphics.getMode()
	map_w = 64 -- Obtains the width of the first row of the map
    map_h = 64 -- Obtains the height of the map
    map_x = 0
    map_y = 0
    offset_x = 0
    offset_y = 0
    inc_offset_x = 0
    inc_offset_y = 0
    map_display_buffer = 2 -- We have to buffer one tile before and behind our viewpoint.
                               -- Otherwise, the tiles will just pop into view, and we don't want that.
    map_display_w = math.ceil(width/32)
    map_display_h = math.ceil(height/32)
    print("map is " .. map_display_w .. " wide and " .. map_display_h .. " tall")
    tile_w = 32
    tile_h = 32
    mapPath = "gfx/testMap.png"
    require "map"
    makeMap(mapPath)
	player = {
		grid_x = 256,
		grid_y = 256,
		act_x = 200,
		act_y = 200,
		speed = 1
	}
	love.keyboard.setKeyRepeat(1,.5)
	min_dt = 1/30
   	next_time = love.timer.getMicroTime()
end

function testMap(x, y)
	if map[(player.grid_y / 32) + y][(player.grid_x / 32) + x] == 1 then
		return false
	end
	return true
end

function love.keypressed(key,unicode)
	if key == "escape" then
		love.event.push("quit")
	end
end

function love.update(dt)
	next_time = next_time + min_dt
	
	if love.keyboard.isDown("r") then
		player.grid_y = 256
		player.grid_x = 256
	end
	if love.keyboard.isDown("up") then
		if testMap(0, -1) then
            if offset_y ~= 0 and ((player.grid_y / 32) - offset_y - 1) <= 2 then
            	offset_y = offset_y - 1
            end
            player.grid_y = player.grid_y - 32
        end
	elseif love.keyboard.isDown("down") then
		if testMap(0, 1) then
			if (offset_y + map_display_h + map_display_buffer + 1) <= map_h and ((player.grid_y / 32) - offset_y + 1) >= map_display_h - 2 then
				offset_y = offset_y + 1
			end
            player.grid_y = player.grid_y + 32
        end
	end
	if love.keyboard.isDown("left") then
		if testMap(-1, 0) then
            player.grid_x = player.grid_x - 32
        end
	elseif love.keyboard.isDown("right") then
		if testMap(1, 0) then
            player.grid_x = player.grid_x + 32
        end
	end
	player.act_y = player.act_y - ((player.act_y - player.grid_y) * dt * player.speed)
	player.act_x = player.act_x - ((player.act_x - player.grid_x) * dt * player.speed)
	inc_offset_y = 1 * ((inc_offset_y - (offset_y * tile_h)) * dt * player.speed)
	inc_offset_y = 1 * ((inc_offset_x - (offset_x * tile_w)) * dt * player.speed)
	print(inc_offset_x, inc_offset_y)
end

function draw_map()
    
    for y=offset_y, (map_display_h + map_display_buffer + offset_y) do
        for x=offset_x, (map_display_w + map_display_buffer + offset_x) do
            -- Note that this condition block allows us to go beyond the edge of the map.
            if map[y][x] == 1 then
				love.graphics.rectangle("line",((x - offset_x) * 32) - inc_offset_x,((y - offset_y) * 32) - inc_offset_y,32,32)
			end
        end
    end
end

function love.draw()
--	x, y = love.mouse.getPosition( )
--	love.graphics.line(0,0,x,y,width,height)
--	love.graphics.line(width,0,x,y,0,height)
	love.graphics.setCaption("Zippy")
	draw_map()
	love.graphics.print("Try the arrow keys ;).\n\"r\" resets.",100,100,r,sx,sy,kx,ky)
	love.graphics.rectangle("fill",player.act_x - (offset_x * tile_w),player.act_y - (offset_y * tile_h),32,32)
	
	local cur_time = love.timer.getMicroTime()
    if next_time <= cur_time then
    	next_time = cur_time
    	return
  	end
  	love.timer.sleep(2*(next_time - cur_time))
	
end

