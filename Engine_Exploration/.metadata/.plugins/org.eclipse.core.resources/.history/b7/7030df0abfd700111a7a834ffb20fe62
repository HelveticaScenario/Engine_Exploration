function love.load()
--	require "middleclass"
--	require "boundingBoxes"
	width, height, fullscreen, vsync, fsaa = love.graphics.getMode()
	map_w = 64 -- Obtains the width of the first row of the map
    map_h = 64 -- Obtains the height of the map
    map_x = 0
    map_y = 0
    map_display_buffer = 2 -- We have to buffer one tile before and behind our viewpoint.
                               -- Otherwise, the tiles will just pop into view, and we don't want that.
    map_display_w = math.ceil(width/32)
    map_display_h = math.ceil(height/32)
    print("map is " .. map_display_w .. "wide and " .. map_display_h .. "tall")
    tile_w = 32
    tile_h = 32
    mapPath = "gfx/testMap.png"
    require "map"
    makeMap(mapPath)
	player = {
		grid_x = 256,
		grid_y = 256,
		act_x = 200,
		act_y = 200,
		speed = 10
	}
	love.keyboard.setKeyRepeat(1,.5)
end

function testMap(x, y)
	if map[(player.grid_y / 32) + y][(player.grid_x / 32) + x] == 1 then
		return false
	end
	return true
end

function love.keypressed(key,unicode)
	if key == "escape" then
		love.event.push("quit")
	end
end

function love.update(dt)
	if love.keyboard.isDown("r") then
		player.grid_y = 256
		player.grid_x = 256
	end
	if love.keyboard.isDown("up") then
		if testMap(0, -1) then
            player.grid_y = player.grid_y - 32
        end
	elseif love.keyboard.isDown("down") then
		if testMap(0, 1) then
            player.grid_y = player.grid_y + 32
        end
	end
	if love.keyboard.isDown("left") then
		if testMap(-1, 0) then
            player.grid_x = player.grid_x - 32
        end
	elseif love.keyboard.isDown("right") then
		if testMap(1, 0) then
            player.grid_x = player.grid_x + 32
        end
	end
	player.act_y = player.act_y - ((player.act_y - player.grid_y) * dt * player.speed)
	player.act_x = player.act_x - ((player.act_x - player.grid_x) * dt * player.speed)
end

function draw_map()
    offset_x = map_x % tile_w
    offset_y = map_y % tile_h
    firstTile_x = math.floor(map_x / tile_w)
    firstTile_y = math.floor(map_y / tile_h)
    
    for y=1, (map_display_h + map_display_buffer) do
        for x=1, (map_display_w + map_display_buffer) do
            -- Note that this condition block allows us to go beyond the edge of the map.
            if y+firstTile_y >= 1 and y+firstTile_y <= map_h
                and x+firstTile_x >= 1 and x+firstTile_x <= map_w
            then
                love.graphics.rectangle("line", 
                    ((x-1)*tile_w) - offset_x - tile_w/2, 
                    ((y-1)*tile_h) - offset_y - tile_h/2,
                    tile_w,
                    tile_h)
            end
        end
    end
end

function love.draw()
--	x, y = love.mouse.getPosition( )
--	love.graphics.line(0,0,x,y,width,height)
--	love.graphics.line(width,0,x,y,0,height)
	love.graphics.setCaption("Zippy")
--	for i=0, (#map)-1 do
--		for j=0, (#map[i])-1 do
--			if map[j][i] == 1 then
--				love.graphics.rectangle("line",i * 32,j * 32,32,32)
--			end
--		end
--	end
	draw_map()
	love.graphics.print("Try the arrow keys ;).\n\"r\" resets.",100,100,r,sx,sy,kx,ky)
	love.graphics.rectangle("fill",player.act_x,player.act_y,32,32)
end

